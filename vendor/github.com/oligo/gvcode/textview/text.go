package textview

import (
	"image"
	"math"
	"unicode/utf8"

	"gioui.org/f32"
	"gioui.org/font"
	"gioui.org/layout"
	"gioui.org/text"
	"gioui.org/unit"
	"github.com/oligo/gvcode/internal/buffer"
	lt "github.com/oligo/gvcode/internal/layout"
	"github.com/oligo/gvcode/internal/painter"
	"github.com/oligo/gvcode/textstyle/decoration"
	"github.com/oligo/gvcode/textstyle/syntax"
	"golang.org/x/exp/slices"
	"golang.org/x/image/math/fixed"
)

// Region describes the position and baseline of an area of interest within
// shaped text.
type Region = lt.Region

type caretPos struct {
	// xoff is the offset to the current position when moving between lines.
	xoff fixed.Int26_6
	// start is the current caret position in runes, and also the start position of
	// selected text. end is the end position of selected text. If start
	// == end, then there's no selection. Note that it's possible (and
	// common) that the caret (start) is after the end, e.g. after
	// Shift-DownArrow.
	start int
	end   int
}

// TextView provides efficient shaping and indexing of interactive text. When provided
// with a TextSource, TextView will shape and cache the runes within that source.
// It provides methods for configuring a viewport onto the shaped text which can
// be scrolled, and for configuring and drawing text selection boxes.
type TextView struct {
	// Font set the font used to draw the text.
	Font font.Font
	// TextSize set the size of both the main text and line number.
	TextSize unit.Sp
	// Alignment controls the alignment of text within the editor.
	Alignment text.Alignment
	// LineHeight controls the distance between the baselines of lines of text.
	// If zero, the font size will be used.
	LineHeight unit.Sp
	// LineHeightScale applies a scaling factor to the LineHeight. If zero, a default
	// value 1.2 will be used.
	LineHeightScale float32

	// CaretWidth set the visual width of a caret.
	CaretWidth unit.Dp

	// SoftTab controls the behaviour when user try to insert a Tab character.
	// If set to true, the editor will insert the amount of space characters specified by
	// TabWidth, else the editor insert a \t character.
	SoftTab bool

	// TabWidth set how many spaces to represent a tab character. In the case of
	// soft tab, this determines the number of space characters to insert into the editor.
	// While for hard tab, this controls the maximum width of the 'tab' glyph to expand to.
	TabWidth int

	// WrapLine configures whether the displayed text will be broken into lines or not.
	WrapLine bool

	// WordSeperators configures a set of characters that will be used as word separators
	// when doing word related operations, like navigating or deleting by word.
	WordSeperators string
	// Brackets and quote pairs that can be auto-completed when the left half is entered.
	BracketsQuotes *bracketsQuotes

	// syntaxStyles define styles originate from the syntax lexer.
	syntaxStyles *syntax.TextTokens
	// decorations define styles from decorations which may be generated by spelling
	// errors, lint warnings, and search highlights.
	decorations *decoration.DecorationTree

	src    buffer.TextSource
	params text.Parameters
	shaper *text.Shaper
	// dimensions of the layouted document.
	dims layout.Dimensions
	// viewport size
	viewSize image.Point
	// line height used by shaper.
	lineHeight fixed.Int26_6
	// scrolled offset relative to the start of dims.
	scrollOff   image.Point
	layouter    lt.TextLayout
	textPainter painter.TextPainter

	// The layout is valid or not. Invalid layout requires a re-layout.
	valid bool
	// caret position in the view.
	caret   caretPos
	regions []Region
	// line buffer for line related operations.
	lineBuf []byte
}

func NewTextView() *TextView {
	e := TextView{}
	e.setSource(buffer.NewTextSource())
	return &e
}

// SetSource initializes the underlying data source for the Text. This
// must be done before invoking any other methods on Text.
func (e *TextView) setSource(source buffer.TextSource) {
	e.src = source
	e.layouter = lt.NewTextLayout(e.src)
	e.BracketsQuotes = &bracketsQuotes{}
	e.decorations = decoration.NewDecorationTree(e.src)
	e.invalidate()
}

func (e *TextView) Source() buffer.TextSource {
	return e.src
}

func (e *TextView) Changed() bool {
	return e.src.Changed()
}

func (e *TextView) SetWrapLine(enabled bool) {
	changed := e.WrapLine != enabled
	e.WrapLine = enabled
	if changed {
		e.invalidate()
	}
}

// Dimensions returns the dimensions of the visible text.
func (e *TextView) Dimensions() layout.Dimensions {
	basePos := e.dims.Size.Y - e.dims.Baseline
	return layout.Dimensions{Size: e.viewSize, Baseline: e.viewSize.Y - basePos}
}

// FullDimensions returns the dimensions of all shaped text, including
// text that isn't visible within the current viewport.
func (e *TextView) FullDimensions() layout.Dimensions {
	return e.dims
}

func (e *TextView) makeValid() {
	if e.valid {
		return
	}
	e.layoutText(e.shaper)
	e.valid = true
}

func (e *TextView) closestToRune(runeIdx int) lt.CombinedPos {
	e.makeValid()
	pos, _ := e.layouter.ClosestToRune(runeIdx)
	return pos
}

func (e *TextView) closestToLineCol(line, col int) lt.CombinedPos {
	e.makeValid()
	return e.layouter.ClosestToLineCol(lt.ScreenPos{Line: line, Col: col})
}

func (e *TextView) closestToXY(x fixed.Int26_6, y int) lt.CombinedPos {
	e.makeValid()
	return e.layouter.ClosestToXY(x, y)
}

func (e *TextView) closestToXYGraphemes(x fixed.Int26_6, y int) lt.CombinedPos {
	// Find the closest existing rune position to the provided coordinates.
	pos := e.closestToXY(x, y)
	// Resolve cluster boundaries on either side of the rune position.
	firstOption := e.moveByGraphemes(pos.Runes, 0)
	distance := 1
	if firstOption > pos.Runes {
		distance = -1
	}
	secondOption := e.moveByGraphemes(firstOption, distance)
	// Choose the closest grapheme cluster boundary to the desired point.
	first := e.closestToRune(firstOption)
	firstDist := absFixed(first.X - x)
	second := e.closestToRune(secondOption)
	secondDist := absFixed(second.X - x)
	if firstDist > secondDist {
		return second
	} else {
		return first
	}
}

// MaxLines moves the cursor the specified number of lines vertically, ensuring
// that the resulting position is aligned to a grapheme cluster.
func (e *TextView) MoveLines(distance int, selAct SelectionAction) {
	caretStart := e.closestToRune(e.caret.start)
	x := caretStart.X + e.caret.xoff
	// Seek to line.
	pos := e.closestToLineCol(caretStart.LineCol.Line+distance, 0)
	pos = e.closestToXYGraphemes(x, pos.Y)
	e.caret.start = pos.Runes
	e.caret.xoff = x - pos.X
	e.updateSelection(selAct)
}

// Layout the text, reshaping it as necessary.
func (e *TextView) Layout(gtx layout.Context, lt *text.Shaper) {
	e.params.DisableSpaceTrim = true

	if e.params.Locale != gtx.Locale {
		e.params.Locale = gtx.Locale
		e.invalidate()
	}
	textSize := fixed.I(gtx.Sp(e.TextSize))
	if e.params.Font != e.Font || e.params.PxPerEm != textSize {
		e.invalidate()
		e.params.Font = e.Font
		e.params.PxPerEm = textSize
	}

	maxWidth := gtx.Constraints.Max.X
	minWidth := gtx.Constraints.Min.X
	if maxWidth != e.params.MaxWidth {
		e.params.MaxWidth = maxWidth
		if e.WrapLine {
			e.invalidate()
		}
	}
	if minWidth != e.params.MinWidth {
		e.params.MinWidth = minWidth
		if e.WrapLine {
			e.invalidate()
		}
	}

	if lt != e.shaper {
		e.shaper = lt
		e.invalidate()
	}
	if e.Alignment != e.params.Alignment {
		e.params.Alignment = e.Alignment
		e.invalidate()
	}

	if lh := fixed.I(gtx.Sp(e.LineHeight)); lh != e.params.LineHeight {
		e.params.LineHeight = lh
		e.invalidate()
	}
	if e.LineHeightScale != e.params.LineHeightScale {
		e.params.LineHeightScale = e.LineHeightScale
		e.invalidate()
	}

	// calculate the final line height used by Shaper
	e.lineHeight = e.calcLineHeight()
	e.makeValid()

	if viewSize := e.calculateViewSize(gtx); viewSize != e.viewSize {
		e.viewSize = viewSize
		if e.WrapLine {
			e.invalidate()
		}
	}

	e.makeValid()
}

// Calculate line height. Maybe there's a better way?
func (tv *TextView) calcLineHeight() fixed.Int26_6 {
	lineHeight := tv.params.LineHeight
	// align with how text.Shaper handles default value of tv.params.LineHeight.
	if lineHeight == 0 {
		lineHeight = tv.params.PxPerEm
	}
	lineHeightScale := tv.params.LineHeightScale
	// align with how text.Shaper handles default value of tv.params.LineHeightScale.
	if lineHeightScale == 0 {
		lineHeightScale = 1.2
	}

	return floatToFixed(fixedToFloat(lineHeight) * lineHeightScale)
}

// ByteOffset returns the start byte of the rune at the given
// rune offset.
func (e *TextView) ByteOffset(runeOffset int) int64 {
	return int64(e.src.RuneOffset(runeOffset))
}

// ReadRuneAt reads a rune at the rune offset runeOff. It returns an error
// while reading from the underlying buffer.
func (e *TextView) ReadRuneAt(runeOff int) (rune, error) {
	return e.src.ReadRuneAt(runeOff)
}

// Len is the length of the editor contents, in runes.
func (e *TextView) Len() int {
	e.makeValid()
	return e.closestToRune(math.MaxInt).Runes
}

func (e *TextView) ScrollBounds() image.Rectangle {
	return image.Rectangle{Max: image.Point{X: e.dims.Size.X - e.viewSize.X, Y: e.dims.Size.Y - e.viewSize.Y}}
}

func (e *TextView) ScrollRel(dx, dy int) {
	e.scrollAbs(e.scrollOff.X+dx, e.scrollOff.Y+dy)
}

// ScrollOff returns the scroll offset of the text viewport.
func (e *TextView) ScrollOff() image.Point {
	return e.scrollOff
}

func (e *TextView) scrollAbs(x, y int) {
	e.scrollOff.X = x
	e.scrollOff.Y = y
	b := e.ScrollBounds()
	if e.scrollOff.X > b.Max.X {
		e.scrollOff.X = b.Max.X
	}
	if e.scrollOff.X < b.Min.X {
		e.scrollOff.X = b.Min.X
	}
	if e.scrollOff.Y > b.Max.Y {
		e.scrollOff.Y = b.Max.Y
	}
	if e.scrollOff.Y < b.Min.Y {
		e.scrollOff.Y = b.Min.Y
	}
}

// MoveCoord moves the caret to the position closest to the provided
// point that is aligned to a grapheme cluster boundary.
func (e *TextView) MoveCoord(pos image.Point) {
	x := fixed.I(pos.X + e.scrollOff.X)
	y := pos.Y + e.scrollOff.Y
	e.caret.start = e.closestToXYGraphemes(x, y).Runes
	e.caret.xoff = 0
}

// CaretPos returns the line & column numbers of the caret.
func (e *TextView) CaretPos() (line, col int) {
	line, p := e.FindParagraph(e.caret.start)
	return line, e.caret.start - p.RuneOff
}

// CaretCoords returns the coordinates of the caret, relative to the
// editor itself.
func (e *TextView) CaretCoords() f32.Point {
	pos := e.closestToRune(e.caret.start)
	return f32.Pt(float32(pos.X)/64-float32(e.scrollOff.X), float32(pos.Y-e.scrollOff.Y))
}

// QueryPos querys the line/column and rune offset of the passed position.
// If pos is outside of the line boundary, it returns zero line and col, and
// a negative runeOff.
func (e *TextView) QueryPos(pos image.Point) (line, col int, runeOff int) {
	x := fixed.I(pos.X + e.scrollOff.X)
	y := pos.Y + e.scrollOff.Y
	combinedPos := e.closestToXYGraphemes(x, y)

	line, p := e.FindParagraph(combinedPos.Runes)

	if x < p.StartX || x > p.EndX {
		return 0, 0, -1
	}

	return line, combinedPos.Runes - p.RuneOff, combinedPos.Runes
}

// invalidate mark the layout as invalid.
func (e *TextView) invalidate() {
	e.valid = false
}

// Set the text of the buffer. It returns the number of runes inserted.
func (e *TextView) SetText(s string) int {
	e.src.SetText([]byte(s))
	sc := e.src.Len()

	// e.SetCaret(0, 0)
	e.invalidate()
	return sc
}

// Replace the text between start and end with s. Indices are in runes.
// It returns the number of runes inserted.
func (e *TextView) Replace(start, end int, s string) int {
	if start > end {
		start, end = end, start
	}

	startPos := e.closestToRune(start)
	endPos := e.closestToRune(end)
	startOff := startPos.Runes
	sc := utf8.RuneCountInString(s)
	newEnd := startPos.Runes + sc

	e.src.Replace(startOff, endPos.Runes, s)
	adjust := func(pos int) int {
		switch {
		case newEnd < pos && pos < endPos.Runes:
			pos = newEnd
		case endPos.Runes <= pos:
			diff := newEnd - endPos.Runes
			pos = pos + diff
		}
		return pos
	}
	e.caret.start = adjust(e.caret.start)
	e.caret.end = adjust(e.caret.end)
	e.invalidate()
	return sc
}

// MovePages moves the caret position by vertical pages of text, ensuring that
// the final position is aligned to a grapheme cluster boundary.
func (e *TextView) MovePages(pages int, selAct SelectionAction) {
	caret := e.closestToRune(e.caret.start)
	x := caret.X + e.caret.xoff
	y := caret.Y + pages*e.viewSize.Y
	pos := e.closestToXYGraphemes(x, y)
	e.caret.start = pos.Runes
	e.caret.xoff = x - pos.X
	e.updateSelection(selAct)
}

// moveByGraphemes returns the rune index resulting from moving the
// specified number of grapheme clusters from startRuneidx.
func (e *TextView) moveByGraphemes(startRuneIdx, graphemes int) int {
	if len(e.layouter.Graphemes) == 0 {
		return startRuneIdx
	}

	startGraphemeIdx, _ := slices.BinarySearch(e.layouter.Graphemes, startRuneIdx)
	startGraphemeIdx = max(startGraphemeIdx+graphemes, 0)
	startGraphemeIdx = min(startGraphemeIdx, len(e.layouter.Graphemes)-1)
	startRuneIdx = e.layouter.Graphemes[startGraphemeIdx]
	s := e.closestToRune(startRuneIdx).Runes
	return s
}

// clampCursorToGraphemes ensures that the final start/end positions of
// the cursor are on grapheme cluster boundaries.
func (e *TextView) clampCursorToGraphemes() {
	e.caret.start = e.moveByGraphemes(e.caret.start, 0)
	e.caret.end = e.moveByGraphemes(e.caret.end, 0)
}

// MoveCaret moves the caret (aka selection start) and the selection end
// relative to their current positions. Positive distances moves forward,
// negative distances moves backward. Distances are in grapheme clusters which
// better match the expectations of users than runes.
func (e *TextView) MoveCaret(startDelta, endDelta int) {
	// Fix Bug: when there is an editing at the end of the text, two successive calls to
	// moveByGraphemes return different result, resulting a different start and end of
	// the selection. We have to do layout earlier to fix this issue.
	e.makeValid()
	e.caret.xoff = 0
	e.caret.start = e.moveByGraphemes(e.caret.start, startDelta)
	e.caret.end = e.moveByGraphemes(e.caret.end, endDelta)
}

// MoveTextStart moves the caret to the start of the text.
func (e *TextView) MoveTextStart(selAct SelectionAction) {
	caret := e.closestToRune(e.caret.end)
	e.caret.start = 0
	e.caret.end = caret.Runes
	e.caret.xoff = -caret.X
	e.updateSelection(selAct)
	e.clampCursorToGraphemes()
}

// MoveTextEnd moves the caret to the end of the text.
func (e *TextView) MoveTextEnd(selAct SelectionAction) {
	caret := e.closestToRune(math.MaxInt)
	e.caret.start = caret.Runes
	e.caret.xoff = fixed.I(e.params.MaxWidth) - caret.X
	e.updateSelection(selAct)
	e.clampCursorToGraphemes()
}

// MoveLineStart moves the caret to the start of the current line, ensuring that the resulting
// cursor position is on a grapheme cluster boundary.
func (e *TextView) MoveLineStart(selAct SelectionAction) {
	caret := e.closestToRune(e.caret.start)
	caret = e.closestToLineCol(caret.LineCol.Line, 0)
	e.caret.start = caret.Runes
	e.caret.xoff = -caret.X
	e.updateSelection(selAct)
	e.clampCursorToGraphemes()
}

// MoveLineEnd moves the caret to the end of the current line, ensuring that the resulting
// cursor position is on a grapheme cluster boundary.
func (e *TextView) MoveLineEnd(selAct SelectionAction) {
	caret := e.closestToRune(e.caret.start)
	caret = e.closestToLineCol(caret.LineCol.Line, math.MaxInt)
	e.caret.start = caret.Runes
	e.caret.xoff = fixed.I(e.params.MaxWidth) - caret.X
	e.updateSelection(selAct)
	e.clampCursorToGraphemes()
}

func (e *TextView) ScrollToCaret() {
	caret := e.closestToRune(e.caret.start)

	miny := caret.Y - caret.Ascent.Ceil()
	maxy := caret.Y + caret.Descent.Ceil()

	// The configures the distance in pixel the caret is from the horizontal border
	// of the editor, at which point we should scroll to adjust the viewport.
	// This ensures the caret can easily be seen when scrolled hotizontally.
	minScrollGap := (e.params.PxPerEm * 1).Ceil()

	var xdist, ydist int
	// calculate x delta, accounting the padding
	if d := caret.X.Floor() - minScrollGap - e.scrollOff.X; d < 0 {
		xdist = d
	} else if d := caret.X.Ceil() + minScrollGap - (e.scrollOff.X + e.viewSize.X); d > 0 {
		xdist = d
	}

	// calcualte y delta
	if d := miny - e.scrollOff.Y; d < 0 {
		ydist = d
	} else if d := maxy - (e.scrollOff.Y + e.viewSize.Y); d > 0 {
		ydist = d
	}

	e.ScrollRel(xdist, ydist)
}

// SelectionLen returns the length of the selection, in runes; it is
// equivalent to utf8.RuneCountInString(e.SelectedText()).
func (e *TextView) SelectionLen() int {
	return abs(e.caret.start - e.caret.end)
}

// Selection returns the start and end of the selection, as rune offsets.
// start can be > end.
func (e *TextView) Selection() (start, end int) {
	return e.caret.start, e.caret.end
}

// SetCaret moves the caret to start, and sets the selection end to end. Then
// the two ends are clamped to the nearest grapheme cluster boundary. start
// and end are in runes, and represent offsets into the editor text.
func (e *TextView) SetCaret(start, end int) {
	e.caret.start = e.closestToRune(start).Runes
	e.caret.end = e.closestToRune(end).Runes
	e.clampCursorToGraphemes()
}

// SelectedText returns the currently selected text (if any) from the editor,
// filling the provided byte slice if it is large enough or allocating and
// returning a new byte slice if the provided one is insufficient.
// Callers can guarantee that the buf is large enough by providing a buffer
// with capacity e.SelectionLen()*utf8.UTFMax.
func (e *TextView) SelectedText(buf []byte) []byte {
	startOff := e.src.RuneOffset(e.caret.start)
	endOff := e.src.RuneOffset(e.caret.end)
	start := min(startOff, endOff)
	end := max(startOff, endOff)
	if cap(buf) < end-start {
		buf = make([]byte, end-start)
	}
	buf = buf[:end-start]
	n, _ := e.src.ReadAt(buf, int64(start))
	// There is no way to reasonably handle a read error here. We rely upon
	// implementations of textSource to provide other ways to signal errors
	// if the user cares about that, and here we use whatever data we were
	// able to read.
	return buf[:n]
}

func (e *TextView) updateSelection(selAct SelectionAction) {
	if selAct == SelectionClear {
		e.ClearSelection()
	}
}

// ClearSelection clears the selection, by setting the selection end equal to
// the selection start.
func (e *TextView) ClearSelection() {
	e.caret.end = e.caret.start
}

// Undo revert the last operation(s) and mark the textview invalid.
func (e *TextView) Undo() ([]buffer.CursorPos, bool) {
	cursors, ok := e.src.Undo()
	if ok {
		e.invalidate()
	}

	return cursors, ok
}

// Redo revert the last undo operation(s) and mark the textview invalid.
func (e *TextView) Redo() ([]buffer.CursorPos, bool) {
	cursors, ok := e.src.Redo()
	if ok {
		e.invalidate()
	}

	return cursors, ok
}

// Regions returns visible regions covering the rune range [start,end).
func (e *TextView) Regions(start, end int, regions []Region) []Region {
	viewport := image.Rectangle{
		Min: e.scrollOff,
		Max: e.viewSize.Add(e.scrollOff),
	}
	return e.layouter.Locate(viewport, start, end, regions)
}

func absFixed(i fixed.Int26_6) fixed.Int26_6 {
	if i < 0 {
		return -i
	}
	return i
}

func abs(n int) int {
	if n < 0 {
		return -n
	}
	return n
}

func fixedToFloat(i fixed.Int26_6) float32 {
	return float32(i) / 64.0
}

func floatToFixed(f float32) fixed.Int26_6 {
	return fixed.Int26_6(f * 64)
}
